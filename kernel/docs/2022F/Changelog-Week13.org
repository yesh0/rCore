#+title: 更新日志（第十三周）

这周毕设开题报告，没什么时间了。总之上周多做了点东西留到这周讲（

* [[https://github.com/Alan-Jowett/bpf_conformance][=bpf_conformance=]]

提供了挺多 eBPF 测例。可以用来测试解释器和验证器。
最后 coverage 提了 5% 左右，找出了一大堆 bug。

另外还有一点是它自带了一个汇编器，所以现在可以用它来写测例了。
之前手动尝试了一下整个流程， +现在还在搭自动化一点的能和 GitHub Actions 连起来的测试流程。+
现在把它作为一个汇编器整合到测试流程里了，写多了几个测例之后 coverage 终于到 90% 了。
（但也就数字好看而已，并没有什么用。）

（为什么不用 LLVM？因为 LLVM 生成的并不是最终代码，而是混了一些需要 libbpf 处理的内容进去。
这些内容并不是合法的 eBPF 指令。）

** 附加进度

给 =bpf_conformance= 修了两个 bug（

* 函数调用

支持了 eBPF 自己的函数调用：

#+begin_src c
  int addition(int i, int j, int k, int l, int m);

  SEC("prog")
  int main() {
    return addition(1, 2, 3, 4, 5);
  }

  SEC("prog")
  int addition(int i, int j, int k, int l, int m) {
    return i + j + k + l + m;
  }
#+end_src

当然，这个直接用 LLVM 编译是没法直接得到可用的 eBPF 字节码的
——里面还需要 libbpf 重定向的代码。（LLVM 编译汇编也一样。）
所以我们才需要用 =bpf_conformance= 来直接写汇编。

#+begin_src asm
  # Copyright (c) Microsoft Corporation
  # SPDX-License-Identifier: MIT
  -- asm
  # r1-r5 are passed to the callee
  mov r0, 0
  mov r1, 1
  mov r2, 2
  mov r3, 3
  mov r4, 4
  mov r5, 5
  # r6-r9 are preserved
  mov r6, 6
  mov r7, 7
  mov r8, 8
  mov r9, 9
  call local func1
  # r0 contains the return value
  # r0 should contain 1 + 2 + 3 + 4 + 5
  jne r0, 15, failed
  # r6 through r9 should be preserved
  jne r6, 6, failed
  jne r7, 7, failed
  jne r8, 8, failed
  jne r9, 9, failed
  # Success
  mov r0, 1
  exit
  failed:
  mov r0, -1
  exit
  # Function sets r0 = r1 + r2 + r3 + r4 + r5
  func1:
  mov r0, 0
  add r0, r1
  add r0, r2
  add r0, r3
  add r0, r4
  add r0, r5
  mov r6, 0
  mov r7, 0
  mov r8, 0
  mov r9, 0
  exit
  -- result
  0x1
#+end_src

直接看演示吧。

* eBPF maps

eBPF map 其实是 eBPF 里挺重要的部分，现在指针资源管理弄好了终于可以开始实现这一部分了。

现在基本上把验证的部分弄好了，但是还在本地没有 commit。原因是还没有找到什么测试的方法：
C 语言写的测例在 eBPF 里获取 map 的 imm64 指令需要 relocation，
汇编的话 =bpf_conformance= 还不支持 map。

+当然可以手动敲指令，但我觉得不会有人真的这么干的，至少我不想。+

** libbpf

zCore 那边的 eBPF runtime 也有涉及到相关问题，就是现在 eBPF 生态基本上是离不开 libbpf 的。
Clang 生成的文件需要 libbpf 处理，就连 Windows 那边的 ebpf-for-windows 也用到了 libbpf
（看起来是调用了 libbpf 的内部 API）。

现在 libbpf 的 API 大概是 ~加载 -> 内部处理 -> 交给 OS~ ，
而获取字节码的 API =bpf_program__insns= 只是附带的，
需要实际 =bpf_object__load= （把 eBPF 交给 OS 运行）才能返回我们想要的处理后的字节码。

+而我只是想跑一个 map 的测例而已……+

** =bpf_conformance=

总之，用 C 语言来写测例的话，libbpf 是绕不过去的坎，而且 libbpf 会让测试环境与 Linux 绑定：
Windows / BSD 上没法跑测例。基本这条路行不通。

之前谈到的 =bpf_conformance= 可以作为汇编器使用，但是它还没有支持 map 类型。
现在有两个 open issues（[[https://github.com/Alan-Jowett/bpf_conformance/issues/59][#59]], [[https://github.com/Alan-Jowett/bpf_conformance/issues/68][#68]]），想要测试 map 的话可能要等或者是提 PR……

* 待做事项

总之这部分应该算是把之前说的实现函数调用以及进行相对复杂一些的测例测试给实现了？
测例复杂度可以说还不够，但是去找测例然后再整合到测试流程里其实还挺花时间的。
（但现在想一想，好像大多时间还是花在修测试出来的 bug 上了……）

接下来的时间希望能够用户接口整一整，针对 zCore 那边需要的功能实现一个简单的对接示例。
+最后再愉快地选一个许可证，写个花俏的 README。+
