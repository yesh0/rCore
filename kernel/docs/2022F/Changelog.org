#+title: 更新日志

* 日志目录

- 第四周 :: 本文件
- 第五周 :: [[./Changelog-Week5.org]]
- 第六周 :: [[./Changelog-Week6.org]]
- 第七周 :: [[./Changelog-Week7.org]]
- 第八周 :: [[./Changelog-Week8.md]]（用 [[https://marp.app/][Marp]] 查看最佳，用注释也写了一些内容。）
- 第九周 :: [[./Changelog-Week9.org]]
- 第十周 :: [[./Changelog-Week10.org]]
- 第十一周 :: [[./Changelog-Week11.org]]

* 尝试把之前同学 eBPF 的代码跑起来
从 [2022-10-02 Sun] 到 [2022-10-03 Mon]，还没成功。

#+begin_quote
虽然还没有决定是要尝试 eBPF 方向还是 swap 那边，所以先把复现一下再说。
但是前面同学实现的 backtrace 还挺方便的，所以无论是 swap 还是进一步加强 eBPF 应该都会基于这个分支。
#+end_quote

下面直接把 commit message 复制过来了：

    Bumped dependency versions to get things compiled
    
    * Updated rust-toolchain
    * Bumped dependency versions
      - trapframe
      - buddy_system_allocator
      - executor
      - isomorphic_drivers
      - riscv (previous versions causing page faults)
    * Blindly removed some features
      - nll
      - untagged_unions
      - optin_builtin_traits
      - global_asm
      - alloc_prelude
      - const_fn
      - const_in_array_repeat_expressions
    * Modified Makefile, no idea if done correctly
    * Replaced llvm_asm! with asm! (for RISC-V only)
    * Removed read_user_fixup, no idea what is it for

因为想用 ~asm!~ 取代 ~llvm_asm!~ 所以把整个依赖以及 toolchain 胡乱升级了一遍。
最后到了 shell 出现提示符，但是不能输入内容，现在还在顺着 async 链来找是哪出了问题。

另外看到同学[[https://zhuanlan.zhihu.com/p/137733625][下一代 Rust OS：zCore 正式发布 - 知乎]]的文章，里面说：

#+begin_quote
对于 Rust，Fuchsia 官方上个月发布的一份语言政策（知乎上也有所讨论）中明确表示，不会将 Rust 用于编写内核，原因是内核要使用工业级别的稳定技术：

    Rust is approved for use throughout the Fuchsia Platform Source Tree, with the following exceptions:
    * kernel. The Zircon kernel is built using a restricted set of technologies that have established industry track records of being used in production operating systems.

而我们希望通过 zCore 的实践表明：Rust 是适合编写内核级代码的，并且比 C/C++ 更能胜任这一任务。
#+end_quote

只能说，nighty 它的名字就意味着不可能是“工业级别稳定”。
从现在人人都用 nightly 版本的状况来看，要跟上 Rust 的版本更新本身就是一个非常大的维护开销。
这种东西也不是说自己项目管理做好了就可以的，而是你想要更新你必须确保你所用的所有库都可以顺利更新。
谷歌不知道，rCore 的依赖库有多少 fork 过来的现在都抛荒了都。

** debug 笔记

尝试跑起来的时候被一个上游库的 bug 卡了好久，但也因此稍微熟悉了一下 debug 的流程。

*** 流程

工具无非就是 GDB 以及 QEMU，但是课程上并没有太讲 QEMU Console 的使用。如果想要更随心所欲地查看虚拟机状态，那么可以尝试一下 QEMU Console，按 =Ctrl+X C= 进入。
Makefile 的 debug 里 QEMU 是后台运行的，没法直接进入 Console，需要多打几个命令。（另外调用的似乎是 x86_64 的 GDB，所以反汇编全是错的。）

#+begin_src console
  $ cd kernel
  $ # 在一个终端输入：
  $ make build justdebug ARCH=riscv64 LOG=debug SMP=1
  $ # 另开一个终端：
  $ RUST_GDB=riscv64-unknown-elf-gdb rust-gdb target/riscv64/release/rcore -x ../tools/gdbinit
#+end_src

Console 的几个常用命令：

- ~info mem~ :: 页表！一览无余。
- ~info registers~ :: Privileged 的各种寄存器都有。
- ~log item1[,item2[,...]]~ :: 开启某样日志，或用 ~log none~ 关闭。
  可以与 GDB 配合获取某一段执行期间的详尽日志。（不然真的看不过来。）
- ~xp /8xg 0x03fff000~ :: 例如查看 0x3fff000 此处物理地址的内容。
  前面的 =/8xg= 里的 =g= 指以 =u64= 为输出单位， =8= 表示输出 8 个单位， =x= 十六进制。

*** 上游的一个 bug

是 [[https://github.com/rcore-os/riscv/]] 的一个小 bug，已经提了 [[https://github.com/rcore-os/riscv/pull/8][PR]]。
基本上就是页表的非根节点的 A/D 位必须为 0，但是库里为了兼容 U540 把所有有效页表项的 A/D 位硬性写成 1 了，本来这件事应该是操作系统来选择而不是由库来干的。

大概只在 QEMU 7.0 或以上版本出现，因为之前版本很宽松而没有检查这一点。

#+begin_quote
Debug 流程挺痛苦的，又有谁能想得到呢……基本上是：
1. QEMU Console ~info mem~ 发现页表完完全全正确。
2. ~log mmu~ 打印日志，最后没办法了，顺着日志找到 QEMU 源代码实现页表查找的代码。
3. 看了几遍，不好找。假设是最近引入的问题，用 =git blame= 找到一个几个月前引入这个检查的 commit。
4. 回去 ~info registers~ 看 =satp= ，找根页表逐级找下去发现 A/D 位是 1。
5. 接下来只要找到对应代码就可以了。

题外话：
我这里是因为设置了 A/D 而 page fault，但是其实 U540 没有设置 A/D 位也会报错这一点也在标准里写了：
硬件不支持实时设置 A/D 位就会 page fault。这一点应该是给操作系统软件补全留出空间。说不定当时的同学调 U540 板也痛苦了好久……
#+end_quote

* 尝试跑起来（其二）：输入问题
[2022-10-04 Tue]

** Async 的调用“栈”

大概看起来的流程是 ppoll -> poll -> 先挂起，等中断传过来之后通过哪里的 bus 用对应的 waker 唤起携程来执行。

但是……目前看起来 UART 完全没有中断传过来，因为没有其它外设中断，所以也不知道只是 UART 有问题还是怎样。
跑去看了 =mie= 寄存器，没问题。
跑去用 ~xp /1xb 0x1000000N~ 看了一下 UART 寄存器的内容，没问题。（ 似乎 QEMU 只支持一字节一字节地看。）

** PLIC 根本没有初始化

回去看[[https://learningos.github.io/rCore-Tutorial-Book-v3/chapter9/2device-driver-1.html][外设平台与串口驱动程序 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档]]，发现原来还有一个 PLIC，
然后打点发现 PLIC 初始化代码压根没有运行……
最后发现是 =compatible= 属性原来应该是当作一个字符串列表来处理的，但是代码里把它当作整一个字符串了……

去看了一下 device tree 规范，从最开始的 v0.1 =compatible= 就是 =stringlist= 类型……
顺便看了一下 QEMU，这次是 6.1 版本开始就会有的问题，由[[https://github.com/qemu/qemu/commit/60bb5407f02b9d7cf7078ff339cbae961b7e98cc][这个 commit]] 引进。

#+begin_quote
Property name: compatible
Value type: <stringlist>
#+end_quote

rCore 文档里也认为它是个字符串……为了不误导太多人总之去给提了个 PR。 +和硬件打交道想当然而不看规范那真机跑出问题不是当然的吗……+
好了，大致问题消除，可以开始想后面做什么了。

* eBPF Verifier
大概 [2022-10-05 Wed] 开始？

去看了相关的一些文章，内核代码 15k 行没敢去看……

- 指令集：
  - [[https://docs.kernel.org/bpf/instruction-set.html][eBPF Instruction Set - The Linux Kernel documentation]]
  - [[https://github.com/iovisor/bpf-docs/blob/master/eBPF.md][Unofficial eBPF spec - iovisor/bpf-docs]]
    这个和上面的有些不符……例如 =0x87= 的 =NEG= 指令。
  - [[https://www.kernel.org/doc/Documentation/networking/filter.txt][Linux Socket Filtering aka Berkeley Packet Filter (BPF)]]
    这个大概是（除了直接看代码之外）最官方的？
    还没开始看，可以从 /BPF kernel internals/ 这一节看。
- Verifier：
  感想是这真的是我能写的吗……
  - [[https://docs.kernel.org/bpf/verifier.html][eBPF verifier - The Linux Kernel documentation]]
    大概把要检查的东西以及检查逻辑说了一遍。
  - [[https://lwn.net/Articles/794934/][Bounded loops in BPF for the 5.3 kernel]]
    令人头大。摘两个点：
    - State pruning
    - 对寄存器/栈里的值的逻辑推断。

其它一些现有的用户态的实现似乎都不太验证程序，毕竟用户态嘛……

+要不咱们不验证了吧？+

** 进度

*** DONE 验证单个指令的正确性

- 简便起见，禁止使用旧的 BPF 的指令。
- 规范里说指令里未使用的域 *应* 置零，我们这里强制 *必须* 置零。
- 原子操作的数据长度是 32 位或 64 位。至于真正的支持那留给 JIT 了。
- 寄存器，R10 是只读的，其它十个可读可写。

*** DONE 简单的结构检查

- 不允许不可达的代码。但是 ~if 0~ 或者更复杂的逻辑上不可达的我们没法判断。
- 不允许越界的跳转，例如跳到代码块外，跳到指令中间（128 位的宽指令）或是跳到当前指令。
- 不允许 open-ended 的代码块，也就是一个代码块最后要不是跳转走，要不必须 BPF_EXIT 返回。

*** TODO 复杂的状态枚举检查

- [ ] 值的推断信息记录、更新、合并
  - [ ] 指针
  - [ ] 整型
- [X] 实现一个推断使用的 VM
- ...

**** 一些检查要点

- 值可以是这些类型：
  - 未初始化：完全不能使用，只能被覆盖。
  - 指针：不同允许进行的操作不同，要储存已知以及推断信息。
  - 整型：要储存推断信息，例如每一位的可能状态以及大小范围等等（要检查溢出）。

- 要检查 callee saved 寄存器是不是被还原了。
- 对操作/每一个调用函数都需要知道它们对参数类型需求并检查。
- 循环不允许深度太大。

**** 一些思路

- +思路一：放弃。+
- 思路二：
  - 和解释器对照着写，感觉上还是挺相像的，毕竟验证也需要知道每一步的具体语义以及副作用等等。做梦的话能用不同的 trait 实现来让解释器直接变成验证器就最好了。
  - 在之前分块的基础上，记录下每一个代码块需要访问/修改的值。这样大概可以在分支的时候做点分支合并的工作。
  - 另外可能还有一个省事的思路，就是在 JIT 的时候插检查指令，例如给循环记个数什么的。
  - 最后的思路就是把“太复杂”的程序全部拒掉（

*** TODO 测试、文档、开源

遥遥遥遥无期。

** 看的一些其它内容

- [[https://lwn.net/Articles/645169/][bpf: introduce bpf_tail_call() helper]]
  现在对 eBPF 可以做的东西还没有一个概念。
  看起来现在 Linux 是可以把不同的函数放在一个 ELF 的不同段里然后调用？
  但是这要怎么检查相互调用……（尾递归优化就先不要想了吧。）

- [[https://docs.kernel.org/bpf/btf.html][BPF Type Format (BTF) - The Linux Kernel documentation]]
  Debug 信息，例如 verifier 可以给出更详细的出错信息。

- 上面那个 [[https://lwn.net/Articles/794934/][Bounded loops in BPF for the 5.3 kernel]] 的评论里提到了一篇论文，
  但 ecree（应该是内核维护人员）认为内存开销大而且安全性有待商榷（但肯定比我们的安全），
  评论里还提了一点，可以由用户态给内核提供一些可验证的提示，例如：
  - 哪些是跟踪的时候可以当作常量的值，
  - 环结构在哪里，
  - 哪个块入度比较多而状态重复大，适于作为状态合并点？
  因为都是可以验证或是不会影响验证的正确性的，发现有不对的时候直接整个拒掉就好了。

  但我们还是摸 Linux 石头过河吧……

** eBPF 官方文档整理

来源 [[https://www.kernel.org/doc/Documentation/networking/filter.txt][Linux Socket Filtering aka Berkeley Packet Filter (BPF)]]

1. 建议 32 位机器直接用解释器，不然 64 位寄存器各种映射起来太麻烦了。
2. 目前支持的函数调用参数个数最多五个。
3. 好消息：只有 87 条指令；坏消息：似乎文档里暂时没说每条指令具体是什么。
4. 因为它说指令是尽量符合一般架构指令的（如 x86_64），所以我猜其中的 *某一些* 32 位指令会把上半清零（
   - mov 清
   - or 不清
   - 绝望
5. 哈哈哈没有详细 spec 的样子呢，去看解释器源码了。
6. 还有一种可能就是这些都是未定义行为，verifier 应该检查出来，但 interpretter 随你怎么样。

*** 阅读 Linux 解释器

可能还是直接看代码方便一点……总之位置是在 kernel/bpf/core.c 里的 =___bpf_prog_run= 函数。

**** Rust 实现：分支跳转表

+里面用了挺多宏的，用 Rust 的宏大概还能进一步简化。+ 别做梦了不能。
+但是不清楚 Rust 的 ~match~ 内部会不会优化成跳转表。+ 用 godbolt 看了一下是会优化的，那就放心用了。还剩下的就是各种常量导入。
之前同学的 ebpf2rv 没写许可证，所以还是到现有的开源项目那边复制常量过来了。

看源码会清晰一点，而且也有一些关于未定义行为的提示。

**** Rust 实现：宏

Rust 和 C 的宏……不能说一模一样，只能说毫无关系。
Linux 里这部分的宏不过百来行，我现在写 Rust 的 procedural macro 已经快五百行了……还要学好几个第三方库……
（因为 Rust 的普通宏目前为止是不能在 match 的分支上使用的，有的时候反而是字符串替换更灵活简单一些。）
（顺便手动实现了个疑似 ~#ifdef~ 的东西……）

**** Rust 实现：泛型

现在想做的解释器会有大概几个泛型类型：
- =Value= :: 应与 =u64= 直接兼容，但是也可以通过实现 =Add=, =Sub= 等 trait 换用其它可以跟踪值并进行安全检查的类型替代。
  - 这样应该 verifier 就可以直接用解释器来进行逻辑分析了，当然 =Value= trait 还是要重新实现一遍。
- =Vm<Value>= :: 储存寄存器以及栈对应的值的接口。

**** Rust 实现：许可证问题

基本是对照着 Linux 里的实现来的，原本觉得如果抄得太过火了可能有 GPL 问题，但最后代码基本毫无关系了 thanks to Rust。

**** 一些 Spec

发现有些地方理解出了问题，总之这里记录一下。

- 离谱其一：
  文档是这样的：
  #+begin_quote
  - the wide instruction encoding, which appends a second 64-bit immediate value (imm64) after the basic instruction for a total of 128 bits.

  ...

  Instructions with the BPF_IMM mode modifier use the wide instruction encoding for an extra imm64 value.
  #+end_quote
  代码是这样的：
  #+begin_src rust
  	DST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;
  #+end_src
  也许是我理解出问题了但怎么想不应该是 ~insn[1]~ 整个是个 imm64 吗？

- 其二： =BPF_NEG= 的确是取负的一元操作符，和 =src= 无关，但是文档：
  #+begin_quote
  BPF_NEG    0x80    dst = ~src
  #+end_quote
  +开始怀疑 docs.kernel.org 到底是不是官方的文档……+
  有人去改一个吗（

- 一些其它观察：
  - 解释器里用到了 =BPF_REG_AX= 这样一个不属于 eBPF 应用程序的寄存器，说是 JIT 里用这个是为了 blinding，但解释器只是作为中间寄存器而已。

  - ALU 里的单元操作符（？）永远是 =BPF_K= （即置零）。

* 待续……

想了想还是按周数分不同的记录吧。这边的长度也开始回顾起来有点累了。
