#+title: 更新日志（第九周）

这周其实也是按之前汇报的时候的计划进行。

* 代码方面

** 代码块级别的验证

之前实现的时候还没有开始读内核代码，所以完全没有考虑还有 =BPF_PSEUDO_CALL= 这种东西，
现在补全了这方面的简单验证。

** 主体验证器部分

本来在写值的追踪部分的代码，之前标量的已经基本实现，普通指针的也不难。
但是指针后面一般会对应一部分的内存结构，所以也顺便把内存访问验证的部分给写了一下。

- 目前实现的访问验证有：
  - 非法区域，对应一些不应被读写的资源指针。
  - =struct= 的访问验证：标量随便读写，主要会验证读指针。
  - 栈指针：因为编译器会把放不下的变量放到栈上，所以放栈上的变量需要像寄存器一样尽量保留原来的信息。
- 还没实现的：
  - 可变长内存区域的验证：这个主要还在犹豫接口要怎么设计，因为这个需要在分支遍历的时候用到：
    - 我们有 ~(data_start, data_end)~ 两个指针，
      程序需要通过 ~if data_start + size <= data_end~ 来验证对应内存至少有 =size= 可读。
    - 可能需要和分支遍历一起写。

** 解释器框架相关

原来写解释器（也就是预想的验证器主体循环）的时候没有考虑太多，
现在在把验证器这边的功能弄完可能解释器那边也要相应改动，例如：

- 原来简单起见变量基本都是值传参，现在一个值里的东西太多了，性能上最好还是回到引用。
- 函数，还是函数，因为函数是依赖外界实现的，这部分可能需要在定好外界 API 之后才能接上。
  - 还有，现在有一个非常特殊的 helper 函数 =bpf_tail_call= ，进行尾调用。
    无论是解释器、验证器、JIT，都需要对这个东西进行特殊处理，
    目前 Linux 里是在验证器部分直接把字节码写成一个内部非标准字节码来强制 JIT 和解释器对其特殊处理。
- 分支遍历，原来接口不够灵活。

* 测试方面

Unit test 写起来跑起来真的非常令人安心。

** 测例

原来用 Makefile 稍微自动化了一下用 Clang 编译成字节码再测试的流程，
但是现在涉及重定向的（例如函数）部分的代码因为 Clang 生成的代码有重定位问题，
所以现在还是只能自己手写 eBPF 字节码来构建测例……

** 测试 Coverage

找到个 [[https://github.com/xd009642/tarpaulin][Tarpaulin]] 可以汇总 Rust 库的 test coverage，
之后可能写测试的时候可能可以尝试提高一点覆盖率。

现在覆盖率是 60% 左右（

但之后如果开始测试 Linux 那边的测例的话，应该无论如何覆盖率都会上去的吧（

* 文档方面

- 把之前的数值/指针跟踪相关的内容加进去了。
- 开始阅读内核分支遍历相关的内容 +好像这部分还好？可能是错觉吧+
