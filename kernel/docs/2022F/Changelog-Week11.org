#+title: 更新日志（第十一周）

* Helper 函数的调用

- 解释器：简单实现了对外的接口，主要是通过解释器来构想接口。
- 验证器部分：实现参数校验部分，返回值校验因为想要同时实现资源分配的跟踪校验，所以还在构想对外的接口。

目前的设计是：
- 解释器：Helper 函数是函数指针数组。
- 验证器：Helper 函数是函数对象：
  - 理论上外部可以传入各种自定义的函数对象来实现复杂的验证。
  - 但是现在希望能够对外提供一个满足绝大多数需求的函数对象 =struct= ，
    免得用户调用接口太过麻烦。

因为有了函数，现在把测试的编译从 =O0= 变为了 =O1= 。

还需要做的：
- 实现资源的跟踪：
  - 一个 helper 函数可能会：
    - 申请资源
    - 释放资源
    - 调用资源
  - 资源的分类：
    - 可以有多个的资源
    - 只能有一个的并且与其它资源冲突的（如自旋锁）
- 其它需要的验证：
  - 程序返回时必须正确释放所有资源
  - 程序不能使用已经释放的资源
- 为实现上面的验证：
  - 我们需要每一个量/指针/资源都分配一个对应的 id（跟着 Linux 的实现）
  - 我们需要给所有指针/指针指向的对象都指定一种类型
  - 我们需要在虚拟机里加一个所有资源的汇总，并在必要时刻对其进行验证
    - Linux 里貌似没有那么复杂，就是每释放一个资源就把整个栈和所有寄存器扫描一遍，
      有相同 id 的值的话（也就是之前把指针复制来复制去放到了其它地方），
      就直接把这个值置成不能使用的未知值。

另外在有了值 id 之后可以做的：
- 能够更精准地跟踪值：如果把 =b= 复制给 =a= ，此时两个值 id 相同，
  当 =a= 的范围更新时我们可以同时将 =b= 的范围缩小。
  - 当然当值修改的时候我们需要记得更新 id。
- 能够尝试对对 skt 类型的程序进行支持，这方面还需要再了解多一点。
  - skt 程序可以对外界来的网络包进行处理，因为网络包的大小未知，
    所以程序需要对其边界进行判断，而我们也需要跟踪验证。

* Cranelift JIT 相关

看了一下使用 Cranelift 来进行 JIT 的方法，应该是可以的。

涉及的接口主要有：
- [[https://docs.rs/cranelift-codegen/0.90.0/cranelift_codegen/ir/trait.InstBuilder.html][cranelift_codegen::ir::InstBuilder]]:
  可以用的指令，看起来 eBPF 用到的指令都有，甚至还有原子操作的指令。
- [[https://docs.rs/cranelift-frontend/latest/cranelift_frontend/struct.FunctionBuilder.html][cranelift_frontend::FunctionBuilder]]：
  函数的构建方法，我们至少会用到里面的 =create_sized_stack_slot= 方法。

因为 Cranelift 其实是比字节码高一层的，所以我们写起来反而可能会麻烦一点……

好处是：
- 不用不同平台写汇编了，单元测试也可以省一省。
  （Cranelift 已经可以用到生产环境里了，至少应该比自己写的汇编器可靠一点吧。）

坏处感觉还挺多：
- 平台仅限于 Cranelift 的几个，如果真的想放到其它平台，
  那么只能 Cranelift 提代码，这代码量就多了。
- Cranelift 比字节码高一层的，
  从字节码转到 Cranelift 也麻烦，
  转换的开销可能也挺大。

毕竟我们需要的其实只是一个汇编器而已。
遗憾的是 Rust no-std 下并没有这种东西，Cranelift 里面的汇编器又只是内部使用，接口不清。
C 语言里看起来有一些，但不知道要怎么比较轻松地去掉对标准库的依赖。

最后可能还是只能自己写。
