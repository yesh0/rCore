#+title: 更新日志（第十四周）

* BPF map 支持

** 总结一下原理

eBPF 里 map 的操作主要可以分为“获取 map 指针”和“map 相关的 helper 函数”两部分。

前一个的话，这里的指针需要通过一个特化的 64 位立即数的指令来获取：

|                      | 8 bits (LSB) | 4 bits     | 4 bits | 16 bits | 32 bits (MSB)  | 64 bits        |
|----------------------+--------------+------------+--------+---------+----------------+----------------|
| 普通 64 位立即数指令 | =0x18=       | 目标寄存器 | =0=    | =0=     | 立即数低 32 位 | 立即数高 32 位 |
| 特化立即数指令其一   | =0x18=       | 目标寄存器 | =1=    | =0=     | map 文件描述符 | =0=            |
| 特化立即数指令其二   | =0x18=       | 目标寄存器 | =5=    | =0=     | map 索引变化   | =0=            |

为什么指令里需要用文件描述符或者是索引来间接得到指针，而不是直接把指针写在代码里？
因为普通 64 位立即数指令并没有提供任何的类型信息，所以验证器不会允许程序直接把 64 位数字当作指针用；
而通过引入中间特化的指令这一层，验证器才可能得知类型信息。

Helper 函数验证这一部分，主要是 map 相关的 helper 函数会读取内存内容，这方面要做边界检验。

例如，一个 map 的键为 16 字节，值为 32 字节，那么下面这种代码就不应通过验证：

#+begin_src c
  int main() {
    char key[4] = {};
    // 应提供 16 字节可读内存，但只初始化了 4 字节
    bpf_map_lookup_elem(map, key);
    return 0;
  }
#+end_src

总之这两类操作都验证了，测试也算勉强凑了一个。

** 整合

虽然把验证器加进现有的 zCore eBPF 实现里去应该大部分代码没有问题，但是 map 的 relocation 的话还会有一点问题。

总之现在这部分其实放着了，主要是下面的尝试。

* Cranelift JIT

还是之前说过的 Cranelift，稍微尝试了一下用它来写 JIT。

用 Cranelift 的 API 的话，其实并不比写解释器难。

（看演示吧。）

现在还要做的是：
1. 写完 JIT。
2. 写一个函数之间链接的 =Module= 实现。（Cranelift 自带的实现是需要 =std= 的。）
3. 做完之后，之前所有的测试应该都可以在这个 JIT 实现上跑，只是需要提供些运行时。

之后应该可以直接在用户态展示 =no_std= 的 JIT 实现，但这样好像又没有回到操作系统上去，
相当于是半个 ebpf-for-windows？
