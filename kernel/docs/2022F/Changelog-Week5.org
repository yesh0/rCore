#+title: 更新日志（第五周）

下面是第五周（后半）的更新记录。前半以及各周索引在 [[./Changelog.org][Changelog.org]]。

* 使用 eBPF+kProbes 与 tokio-rs/console 整合可行性考察

从上到下：
- =tokio-rs/console= :: 数据的接收方，对数据整理并进行可视化。
- =gRPC=, =protobuf= :: 数据的承载格式以及交换方法。
- 用户态程序 :: 从 eBPF 处接收数据，中转站。
- eBPF 程序 :: 从内核各处获取相应信息。（下面会汇总一下“相应”信息大概有什么。）
- Async Runtime :: 提供协程的上下文信息。

为此，我们需要：
- 把数据最终送到 =tokio-rs/console= ：操作系统需要有网络或 socket 实现。
- 用户态程序从 eBPF 获取信息：目前来看最方便的需要实现 perf events 相关的内容。
- eBPF 程序获取信息：kProbes 相关，另外在 Async Runtime 里也要插入一些位点。
- Async Runtime：需要改代码来收集上下文信息，但是 rCore 用的 runtime 看起来比较简单还好。

可收集的相关信息主要是异步的 pollable 资源信息，包括：
- 任务信息
- 资源信息（例如锁等）

这可能要对 Rust 的异步机制有更深一点的认识。希望上面的信息都能在 async runtime 里收集到吧，不然 kProbes 也救不了。

另外上学期同学实现的内容似乎还不足以实现 eBPF 和用户态的有效通信。网络 IO（或者 QEMU 有速度快点的 serial 吗）可能也够呛。当然把 =tokio-rs/console= 整个放到用户态里也是一种办法。

** 计划

把 Rust 异步的 poll 机制以及 rCore（或者跑去 zCore 看看？）里的 async runtime 的整合看一看。

* eBPF 解释器构建
在 [2022-10-12 Wed] 大致结束。

解释器要说的话写起来是比较简单的，但是因为 interpreter 和 verifier 的代码逻辑有相当一步分是重合的，所以设计时预留了一定的扩展性
——或者可以说写完 interpreter 后 verifier 进度就有 10% 了（代码量可能比例更多，但是后面没法照抄 Linux 思路了）。

现在留了两个 verifier 可用的地方：
- =Value= trait :: 跟踪对某一个值的操作。解释器里所有的对 eBPF 虚拟机内数值的操作都经过了这个 trait 的封装。
- =BranchTracker= trait :: 跟踪跳转以及跳转对应的目标条件。解释器会在 tracker 有需要的时候停下来把控制权交回 verifier，以便进行分支遍历等操作。

** 下面计划

- =BPF_CALL= 实现：
  - 我实在没有找到什么文档。现在看起来有几种 =BPF_CALL= （可能重合）：
    - 调用 kfuncs
    - 调用同一个 ELF 文件内其它代码段的函数（可能需要用尾递归的 kfuncs）
    - 调用同一段内的某个位置的函数
  - 总之是好乱……暂时不想实现，可能 verifier 差不多之后和 JIT 那边统一一下接口再说。
- 值跟踪：把 =Value= trait 给实现一遍，跟踪算法看看能不能按 Linux 的来……
  - [[https://docs.kernel.org/bpf/verifier.html]] 这里是简要的概述，大概看得出是使用 =tnum (mask+value)= 跟踪位信息，同时跟踪有符号 & 无符号可能的最大最小值。
  - [[https://bbs.pediy.com/thread-267956.htm]] 找到一篇分析，但其实也非常简略，但是给出了对应算法所在函数：
    - =adjust_reg_min_max_vals= :: 值的上下界计算
    - =check_max_stack_depth= :: 函数调用的检查
  - 一些要检查的内容：
    - 指针与数值：
      - 指针与指针的运算只允许减法，只允许同一块数据上的指针进行运算。
      - 指针与数值允许加减法
      - 数值之间自由运算
    - 指针解引用：
      - 指向定长的 =struct= 的指针，需要保存对应类型的信息，offset 多少的地方对应的是多大的数据类型，不能把 =char *= 当 =u64= 读了，不能把 =i32= 当 =u8= 读了。
      - 指向不定长的，例如数据包的指针，需要对长度做判断及推断。见内核文档的例子。
    - 数值/指针相对关系推断：
      - 例如： =p1, p2= 为一个数据的开头结尾，数据大小未知，则 =if (p2 - p1 > 7)= 之后应能推断出 =p1[6]= 是可以访问的。
        当然，如果是 =if (p1 - p2 > 7)= 则可能有溢出的情况，所以不能得出 =p2[6]= 的结果。
      - 例如： =for (int i = 0; i < 100; ++i) {}= 则执行这一段过后 =i= 对应的寄存器必定为 100。
      - =if (i < j && j < k)= 之后有 =i < k && k - i > 2= 。
    - 未初始化值的跟踪：
      - 退出前函数调用的 callee saved 寄存器需要恢复，可以用特殊类型的指针表示。
      - （虽然我们还没有实现 =BPF_CALL= ……）函数调用后，R1 到 R5 设为未初始化值。
    - 总结：
      - 值之间有依赖关系，比较时可能要把整棵树搜索一遍避免成环。简单起见我们只追踪加减的大小关系，乘除放弃。
      - 指针之间的关系通过一个隐形的长度值来表示，指针有类型以及所属信息，不同数据对应的指针之间无法比较。
- 跳转跟踪：主要需要根据分支条件对分支之后对应的数据进行推断。
  - 不知道 Linux 现在怎么做的，可能可以设一个跳转上限。
  - 最好做些分支合并，也许可以牺牲一些跟踪数据的精度。

* Verifier 构建

** 用 =Value= trait 实现值的跟踪

用 Rust 来构建一个图……我已经被 Rc 弄晕了（

*** 各个数据之间的关系
- =Value= :: 某个 =Value= trait 的实现，均为只读对象，加减乘除等操作创建的是新的。是关系图中的节点。
- =Relation= :: =Value= 节点之间的连接。
- =OrdGraph= :: 大小关系的有向图。不一定存在这样的 struct，但独立成一个概念会容易讨论些。

*** 希望的对象所属以及 RAII

因为 verifier 是单线程的，用 =Rc= 相关的计数即可。

从例子开始：
- =a, b= 两个值，分别在寄存器 =A, B= 里，令 ~B = c~ 则 =b= 被释放。
  - 关系：VM -> 寄存器 / 栈 -> 值。
- =a, b= 同上， ~a >= b~ 构建了一个关系，令 ~B = c~ 则 =b= 被释放。
  若 =b= 无额外关系， =a, b= 关系被释放；若 =b= 有常数取值，则根据 =b= 的下界将关系转换为对常数的 ~a >= min(b)~ 。
  - =Relation= 可以是与常数的关系，可以是与跟踪值的关系，前者尽量不要再牵涉到对象管理了（也即请用 =enum= 内置）。
  - 关系：
    - =a= -> =r(a, b)= , =b= -> =r(a, b)= : 情形简单，可直接用 =Rc= 。
    - =r(a, b)= -> =a, b= : 用 =Weak= ，更新关系时升级到 =Rc= 。
- =a, b, c= 三个值， ~a >= b + 2 && b >= c + 3~ 两个关系，令 ~B = d~ 则 =b= 被释放。
  合并关系，应有 ~a >= c + 5~ 。
  - 则释放 =b= 时，对所有每一条入的节点构建指向每一个出的节点的关系。
  - 考虑位图的更新，可以象征性地更新一下相等的相邻节点的位图。
- =a, b, c= 三个值， ~a >= b + 2 && b >= c + 3 && a >= c + 6~ ，令 ~B = d~ 则需要合并关系。

另外，因为大小关系有有符号和无符号两套，最简便可能是分成两独立部分来做，但合并大概可以省点空间？
- 对正常程序来说，同一个量肯定要不都是无符号操作，要不就都是有符号操作，所以可以分。
- 也可以在树的大小方面做些限制。

总结：
- =Vm=
  - =Value= (registers, stack)
    - =Relation= (vec / hashmap)
      - =Weak<Value>= (tuple_2 / enum)

*** 从图出发的推断算法

要求推断出真假或无法判断的命题均是 ~a >= b~ 的形式。（ ~a > b~ 可用 ~a >= b + 1~ 表示，等于的话可以用两个来表示但也可以考虑优化。）

以 ~>=~ 关系为图的方向，记 ~a >= b + N~ 中的 =N= 为费，则可分几类情况：
1. =a= 可达 =b=
   - 若路径上最大费非负，则命题为真。
2. =b= 可达 =a=
   - 若路径上最大费大于零，则命题为假。
3. =a, b= 互不可达
   - 若 =a= 可达一个常数，而 =b= 又可由某个常数到达（或反过来），则可看作 (1) (2) 的情形。
4. 其它情况不可知。

可能需要分析一些常见程序才能知道一般情况下的树的大小。应该不会太大吧？毕竟寄存器就那几个……

*** Pruning

+想直接DFS了+

对正常程序的话，一个代码块有二或以上的入度大概就是 =if= 或 =while= 了吧？但是合并状态可能会误判正常程序……
