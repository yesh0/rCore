---
marp: true
theme: uncover
_class: lead
paginate: true
backgroundColor: white
backgroundImage: url('https://marp.app/assets/hero-background.svg')
---

<style>
section {
  text-align: left;
}

ul {
  margin-left: 1em;
}

section::after {
  font-size: 0.8em;
}
</style>
<style scoped>
section {
  text-align: center;
}
</style>

# eBPF 验证器 / 分析器实现

<br>

### 期中进展汇报

- ebpf-analyzer: github.com/yesh0/ebpf-analyzer
  <!-- 项目地址，当然进度还差得远，最后会开源。 -->
- eBPF Hitchhiking: yesh0.github.io/ebpf-analyzer
  <!--
  下面这个可以说是一点源码阅读的笔记或是文档吧，
  我尽量在我阅读 Linux 源码的过程中把整个脉络理一理，把现有的 eBPF 缺失的文档补全一下，记在这里。
  希望能够对之后的同学或者是其它对 eBPF 感兴趣的人有点帮助吧。
  -->

---

### 项目目标

1. 文档方面：
   - 补全官方文档的一些内容
   - 理清 Linux eBPF 验证器的大体框架
   - 如果可以的话，向内核开发者反馈一下文档的错漏
   - 我们这边自己实现的验证器也要注意留文档以及注释
2. 项目方面：
   - 模仿 Linux 实现一个具有类似功能的开源验证器
   - 优化接口，留出自定义空间并对接解释器以及 JIT

---

<style scoped>
blockquote {
  padding-left: 5em;
}

ul {
  margin-left: 1em;
}
</style>

> ### Linux 中的 eBPF 验证器实现
> - #### 功能
> - #### 组成
> - #### 依赖
> ### eBPF 分析器实现
> - #### 进展
> - #### 计划

<!--
然后就是项目进展相关的内容了。
这里从 Linux 的实现讲起，这些内容其实很多我都记录到刚才说的文档里去了，所以也算一个进展回顾。
-->

---

## Linux 的 eBPF 验证器

<!--
Linux 里面的验证器其实做的事情还挺多的，肯定是不只有“验证”的。
它和 eBPF 后面部分，比如解释器或者 JIT 的部分的耦合非常紧密。
-->

### 一些非“验证”性的工作

- 每一个函数所需的栈空间计算
  <!-- 一个函数的栈的空间是 512 字节，但大部分函数都不会把栈用光，所以提供这些信息可以让 JIT 以及解释器省点内核栈 -->
- 重定位信息处理
  <!-- 之所以这些重定位由内核处理，是因为验证器需要这些重定位指令提供的类型信息 -->

<!--
当然，比如说栈空间计算，要获取这些信息的确也就验证器最合适。
我们的验证器实现也会提供这些信息，但是接口会定义更好一点。

后面就是真正的验证相关的了。
-->

### 指令块级别的验证

- 跳转合规、不含不可达代码块

### 程序流程级别的验证（主体部分）

---

## Linux eBPF 验证器主体部分

### 目标：停机问题

遍历**每一种**可能的执行路径，确认指令、数据操作、函数调用等均合法
- 不是所有合法 eBPF 程序都能够通过验证
- 有很多时候需要 eBPF 程序员做一些处理
<!--
不可能是图灵完备的，比如说下面的集合还算比较常用的循环结构吧，就不能用了。
-->

---

### 不能通过验证的 eBPF 范例


- 内存范围相关：
```c
for (int i = 0; i < data_end - data; i++)
  if (((char *) data)[i] == -1)  // out of bound
    return XDP_PASS;

for (char *p = data; p < data_end; p++)
  if (*p == -1)                  // out of bound
    return XDP_PASS;
```
- 栈上变量操作相关：放到栈上的没有对齐的变量难验证
  （汇编代码略）

---

### 与解释器结构相似

|                | 解释器   | 验证器                   |
|----------------|----------|--------------------------|
| 寄存器         | `u64`    | `bpf_reg_state`          |
| 操作寄存器或栈 | 直接更新 | 更新**值**的类型、范围、位图 |
| **内存**相关       | 直接读写 | 检验边界条件等           |
| **分支**跳转       | 更改 PC  | 预判以及遍历分支         |
| **函数**调用       | 直接传参 | 进行参数类型检验等验证   |

<!--
运行的时候差不多也是一条一条指令地尝试去执行。
基本上要把它分为几个部分的话也和解释器差不多，四种检查。
-->

---

### 外部依赖

- 值：标量、指针、各种指针等的允许的操作
  - 标量：由验证器实现
  - 指针允许的操作及实现：可以看作外部提供信息
    <!-- 题外话，似乎为了这个 Linux 里手动实现了一个虚函数表 -->
- 函数：多种函数、参数验证、语义相关验证
  - Helper 函数：
    - 资源分配函数需要验证资源释放
    - 获取锁后的函数调用需要特殊处理
  - 内核函数 kfuncs
- BTF 相关
- ……

---

### 项目进展及计划

- `[-]` 源码阅读文档：进展至“值跟踪”部分 `Week 9-?`

- `[-]` 简单部分
  - `[X]` 每条指令的单独验证
  - `[X]` 不可达代码块验证
  - `[X]` 跳转合法性验证
  - `[ ]` 函数级别的验证 `Week 9`

<!--
简单部分就是不需要跟踪流程的验证。
实现起来的确很简单，但是当时实现的时候，我还没开始仔细看源码，
内部函数这部分在文档里几乎，就是没有，现在看完相关的代码了可以之后补上。
但这部分还是简单的。
-->

---

### 项目进展及计划

- `[ ]` 复杂部分
  - `[-]` 值的跟踪、指针对应内存范围跟踪 `Week 9-10`
  - `[ ]` 分支遍历
    - `[ ]` 分支状态管理 `Week 10-13`
    - `[ ]` 分支合并 `Optional`
  - `[ ]` 验证外部提供的函数 `Week 13`
    - `[-]` 接口定义 `Week 12`
- `[-]` 各种测试

<!--
然后就是复杂的部分。
-->

---

### 谢谢大家！
