#+title: 更新日志（第十六周）

唯一的考试课程被我设 P/F 了，总之已经考完了。现在汇总一下一些工作以及之后的想法。

总之想法还是把 eBPF 验证器 ebpf-analyzer 给继续写下去。
之后等功能实现得差不多了会尝试把项目链接放到 ebpf.io 上去，至少让其它有需要的人能找得到。

* Aya: libbpf 用户态替代

找到了一个 libbpf 的用户态替代：[[https://github.com/aya-rs/aya][Aya]]。
+你说怎么等到学期末才找到呢……人家 1k star 了呢，之前真的一次都没搜出来？+

但是，Aya 现在还只对接了 Linux 的系统调用，要用到我们这边来还有一定的问题。

对此我提了一个 issue：
[[https://github.com/aya-rs/aya/issues/473][Feature Request: Make aya::obj API public to allow usage with different runtime]]。
总之是我接下来会尝试把 Aya 的与 Linux 系统调用无关的部分给独立成为一个 =aya-obj= 的 crate，
独立出来之后就可以用在我们的系统或者是各种测例中了。
+（我的想法是尽量把 =aya-obj= 给弄成 =no_std= 的，但是稍微看了一下代码，看起来有点难。总之之后再说吧。）+
现在已经提了一个 PR（[[https://github.com/aya-rs/aya/pull/475][#475]]），还在等进一步的 review，看起来比较有希望。
=no_std= 的话，现在理论上是可以的。但是为了确保依赖上没出什么问题
（比如 Cranelift 就是标着 =no_std= 但是却不能在 =no_std= 下编译），
还是之后在 =no_std= 环境里实际用一下会比较好。

这部分对于我们这学期的同学其实可能没什么用了，之后弄 eBPF 方向的同学可能可以考虑看看 =aya-obj= （如果我整出来了的话）。

现在 PR 已经合并了，可以在 =Cargo.toml= 里引用 git 仓库使用。
=ebpf-analyzer= 那边也用 =aya_obj= 加了一个测例。

* Relocation, again

** 数据结构重定向

发现了之前漏掉的内核需要进行的另外一种“重定向”：
Linux 里 eBPF 使用的 ~struct __sk_buff~ 和内核里实际的 ~struct sk_buff~ 是不同的。
例如， ~struct __sk_buff~ 里的指针是 32 位的，这当然不对啦。
实际上，内核会把对 =__sk_buff= 的访问的偏移量、读取的数据大小都进行改动，
使其与实际的 ~struct sk_buff~ 符合。

有兴趣的话可以看看这篇文章 [[https://medium.com/@c0ngwang/understanding-struct-sk-buff-730cf847a722][Understanding struct =__sk_buff= - Cong Wang]]。

** 全局数据重定向

我们知道一般程序有 =.data=, =.rodata= 以及 =.bss= 这些段。
操作系统课程里其实也涉及到了相关的内容。eBPF 程序里要实现这样的功能需要内核以及用户侧的配合。

- 内核侧：根据特殊指令，将 map fd 变为 =.data= 等的指针。
- 用户侧：将对 =.data= 等段的访问指令变为内核能够识别的特殊指令。

总的来说，这样子的 eBPF 其实是把一个 map 的值的对应指针当成 =.data= 这些段的数据指针来用了。

现在文档仓库更新了相关的内容， =ebpf-analyzer= 也支持了这样的使用方法。
